// Data
uniform sampler3D tex3D;
uniform float scale_factor;

// Lighting Stuff
const vec3 LightPosition = vec3(0.0, 1.0, 1.0);
const float SpecularContribution = 0.3;
const float DiffuseContribution = 1.0 - SpecularContribution;
const float cellSize = 1.0 / 64.0;

// RayCasting stuff
const float stepSize = 0.01;

vec3 traverseVector;
vec3 ec;

// Compute the Normal around the current voxel
vec3 getNormal(vec3 at)
{
	vec3 n = vec3(texture3D(tex3D, at - vec3(cellSize, 0.0, 0.0)).w - texture3D(tex3D, at + vec3(cellSize, 0.0, 0.0)).w,
				  texture3D(tex3D, at - vec3(0.0, cellSize, 0.0)).w - texture3D(tex3D, at + vec3(0.0, cellSize, 0.0)).w,
			      texture3D(tex3D, at - vec3(0.0, 0.0, cellSize)).w - texture3D(tex3D, at + vec3(0.0, 0.0, cellSize)).w
				 );
	
	return normalize(n);
}

float getLightIntensity(vec3 norm)
{
    float LightIntensity = 1.0;
    vec3 lightVec = normalize(LightPosition - ec);
    vec3 viewVec = normalize(-ec);

    vec3 reflectVec = reflect(-lightVec, norm);
    float diffuse = max(dot(lightVec, norm), 0.3);
    float spec = 0.0;

    if (diffuse > 0.0)
    {
        spec = max(dot(reflectVec, viewVec), 0.2);
        spec = pow(spec, 16.0);            
    }
	
	return SpecularContribution*spec + DiffuseContribution*diffuse;
}

void main(void)
{

    // Get the end point of the ray (from the front-culled faces rendering)
    vec3 rayStart = vec3( gl_TexCoord[0].st, 0 );
    vec3 rayEnd = vec3( gl_TexCoord[0].st, 1 );
    
    // Get a vector from back to front
    traverseVector = rayEnd - rayStart;

    // The maximum length of the ray
    float maxLength = length(traverseVector);
      
    // Construct a ray in the correct direction and of step length
    ec = normalize(traverseVector);
    vec3 step = stepSize * ec;
    vec3 ray = vec3(0.0, 0.0, 0.0);
   
        // The color accumulation buffer
    vec4 acc = vec4(0.0, 0.0, 0.0, 0.0);

    // Holds current voxel color
    vec4 voxelColor;

    // Lighting
    float LightIntensity = 1.0;

    float normalzz = getNormal( ray + rayStart );
    
    // Advance ray
    for (int i = 0; i < int(1.0/stepSize) + 1; ++i)
    {
        if (length(ray) >= maxLength || acc.a >= 1.0) 
        {
            acc.a = 1.0;
            break;
        }

        //LightIntensity = getLightIntensity(normalzz);
        LightIntensity = scale_factor; 
        voxelColor = texture3D(tex3D, ray + rayStart).r;



        // Accumulate Opacity: acc.a = acc.a + (1.0 - acc.a)*voxelColor.a;
        acc.a = mix(voxelColor.a, 1.0, acc.a);

        ray += step;

    }

    gl_FragColor = acc * scale_factor;
    return;
}
